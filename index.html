<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clash Royale Deck Builder</title>
<style>
  body {
    font-family: sans-serif;
    margin: 20px;
  }

  h1, h2, h3 {
    text-align: center;
  }

  #deck-rating {
    text-align: center;
    font-size: 1.2rem;
    font-weight: bold;
    margin-bottom: 10px;
  }

  #megaknight-warning {
    text-align: center;
    font-weight: bold;
    color: red;
    margin-bottom: 10px;
    visibility: hidden;
  }

  #deck-slots {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin-bottom: 20px;
  }

  .slot {
    width: 80px;
    height: 120px;
    border: 2px dashed #aaa;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    cursor: pointer;
    background: white;
  }

  .slot.evo {
    border: 4px solid rgb(140, 0, 140);
  }

  .slot.evo::before {
    content: "EVO";
    position: absolute;
    color: rgba(140, 0, 140, 0.15);
    font-size: 24px;
    font-weight: bold;
    top: 40px;
    left: 8px;
    pointer-events: none;
  }

  #all-cards {
    display: grid;
    grid-template-columns: repeat(auto-fill, 80px);
    gap: 10px;
    justify-content: center;
  }

  .card {
    width: 80px;
    height: 120px;
    border: 1px solid #ccc;
    cursor: grab;
    position: relative;
  }

  .card img, .slot img {
    width: 100%;
    height: 100%;
    object-fit: contain;
  }

  .card.used {
    opacity: 0.45;
    cursor: not-allowed;
  }

  .tooltip {
    position: fixed;
    background: rgba(0,0,0,0.8);
    color: #fff;
    padding: 4px 6px;
    font-size: 12px;
    border-radius: 4px;
    white-space: nowrap;
    z-index: 10;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.05s;
  }

  #filter-container {
    text-align: center;
    margin-bottom: 10px;
  }
</style>
</head>
<body>

<h1>Clash Royale Deck Builder</h1>
<h2>By Jakob K. & Evan N.</h2>

<div id="megaknight-warning">Really? You wanna add Mega Knight?</div>
<div id="deck-rating">Deck Rating: N/A</div>

<div id="deck-slots">
  <div class="slot" data-index="0"></div>
  <div class="slot" data-index="1"></div>
  <div class="slot evo" data-index="2"></div>
  <div class="slot evo" data-index="3"></div>
  <div class="slot" data-index="4"></div>
  <div class="slot" data-index="5"></div>
  <div class="slot" data-index="6"></div>
  <div class="slot" data-index="7"></div>
</div>

<h3>All Cards</h3>
<div id="filter-container">
  <label for="card-filter">Filter: </label>
  <select id="card-filter">
    <option value="all">All</option>
    <option value="ground">Ground</option>
    <option value="air">Air</option>
  </select>
</div>
<div id="all-cards"></div>

<script>
let deck = new Array(8).fill(null);
let cardMap = {};
let allCards = [];
let tooltip = null;

fetch("cards-data.json")
  .then(res => res.json())
  .then(data => {
    allCards = data.items;
    allCards.forEach(c => cardMap[c.name] = c);
    renderCards();
  })
  .catch(err => console.error("Error loading card data:", err));

function renderCards(filter="all") {
  const allCardsDiv = document.getElementById("all-cards");
  allCardsDiv.innerHTML = "";
  allCards
    .filter(c => filter === "all" || c.type === filter)
    .forEach(card => {
      const div = document.createElement("div");
      div.className = "card";
      div.innerHTML = `<img src="${card.iconUrls.medium}" title="${card.name}" draggable="true">`;
      allCardsDiv.appendChild(div);

      // Click to add
      div.addEventListener("click", () => addCard(card));

      // Drag events
      div.addEventListener("dragstart", e => {
        e.dataTransfer.setData("text/plain", card.name);
      });

      // Tooltip
      div.addEventListener("mouseenter", e => showTooltip(card, e));
      div.addEventListener("mousemove", e => moveTooltip(e));
      div.addEventListener("mouseleave", hideTooltip);
    });

  // Update used state
  allCardsDiv.querySelectorAll(".card").forEach(div => {
    const name = div.querySelector("img").title;
    div.classList.toggle("used", deck.some(c => c && c.name === name));
  });
}

document.getElementById("card-filter").addEventListener("change", e => {
  renderCards(e.target.value);
});

// Tooltip functions
function showTooltip(card, e) {
  if (tooltip) tooltip.remove();
  tooltip = document.createElement("div");
  tooltip.className = "tooltip";
  tooltip.innerText = `${card.name}\nElixir: ${card.elixirCost}\nRarity: ${card.rarity}`;
  document.body.appendChild(tooltip);
  moveTooltip(e);
  tooltip.style.opacity = 1;
}

function moveTooltip(e) {
  if (!tooltip) return;
  const padding = 10;
  const rect = tooltip.getBoundingClientRect();
  let x = e.clientX + padding;
  let y = e.clientY + padding;
  if (x + rect.width > window.innerWidth) x = e.clientX - rect.width - padding;
  if (y + rect.height > window.innerHeight) y = e.clientY - rect.height - padding;
  tooltip.style.left = x + "px";
  tooltip.style.top = y + "px";
}

function hideTooltip() { if (tooltip) { tooltip.remove(); tooltip = null; } }

// Deck management
const deckSlots = document.querySelectorAll(".slot");
deckSlots.forEach((slot, i) => {
  slot.addEventListener("click", () => { if(deck[i]) { deck[i]=null; renderDeck(); } });
  slot.addEventListener("dragover", e => e.preventDefault());
  slot.addEventListener("drop", e => {
    e.preventDefault();
    const name = e.dataTransfer.getData("text/plain");
    const card = cardMap[name];
    if (!deck.includes(card)) { deck[i] = card; renderDeck(); }
  });
});

function addCard(card) {
  if (deck.includes(card)) return;
  const idx = deck.findIndex(s => s === null);
  if (idx === -1) return;
  deck[idx] = card;
  renderDeck();
}

// Deck rendering
function renderDeck() {
  deckSlots.forEach((slot, i) => {
    slot.innerHTML = "";
    const card = deck[i];
    if (!card) return;

    const img = document.createElement("img");
    img.src = slot.classList.contains("evo") && card.iconUrls.evolutionMedium
      ? card.iconUrls.evolutionMedium
      : card.iconUrls.medium;
    slot.appendChild(img);

    // Deck slot tooltip
    slot.onmouseenter = e => { showTooltip(card, e); };
    slot.onmousemove = e => moveTooltip(e);
    slot.onmouseleave = hideTooltip;
  });

  document.querySelectorAll(".card").forEach(div => {
    const name = div.querySelector("img").title;
    div.classList.toggle("used", deck.some(c => c && c.name === name));
  });

  updateRating();
  checkMegaKnight();
}

// Deck rating
function updateRating() {
  const ratingEl = document.getElementById("deck-rating");
  if (deck.some(s => s===null)) { ratingEl.textContent = "Deck Rating: Incomplete"; return; }
  const score = 50 + Math.floor(Math.random()*51);
  ratingEl.textContent = "Deck Rating: "+score+"/100";
}

// Mega Knight warning
function checkMegaKnight() {
  const mk = deck.some(c => c && c.name.toLowerCase()==="mega knight");
  document.getElementById("megaknight-warning").style.visibility = mk ? "visible" : "hidden";
}
</script>
</body>
</html>
